/*
 * main.c / Assignment 5 - Multiprocessing in C
 *
 * ZW / CS5600 / Northeastern University
 * Fall 2025 / Sep 30, 2025
 *
 * Description:
 *   This program reads a text file of words (generated by genRandWords-wang.c),
 *   stores each word into a generic queue (queue.c / queue.h), and performs
 *   batch encryption using the modified cipher program (cipher.c) via separate
 *   child processes. Each batch encrypts 100 words at a time, and outputs
 *   results to individual files to avoid overwriting.
 *
 */

#define _POSIX_C_SOURCE 200809L
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>
#include "queue.h"

#define BATCH_SIZE 100          // number of words per encryption batch
#define MAX_WORD_LEN 64         // max length of a word

/* Function: readWordsIntoQueue
* 
* Reads words from a file and stores them into the provided queue.
* Returns the number of words read.
*/
int readWordsIntoQueue(const char *filename, queue_t *q) {
    FILE *fp = fopen(filename, "r");
    if (!fp) {
        perror("Error opening word file");
        return -1;
    }

    char buffer[MAX_WORD_LEN];
    int count = 0;
    while (fscanf(fp, "%63s", buffer) == 1) {
        // Duplicate the word for storage in queue
        char *word = strdup(buffer);
        if (!word) {
            fprintf(stderr, "Memory allocation failed for word\n");
            fclose(fp);
            return -1;
        }
        add2q(q, word);
        count++;
    }

    fclose(fp);
    return count;
}

/* Function: encryptBatch
*
* Sends up to batchSize words from queue to cipher program as a child process.
* The child reads from stdin and outputs encrypted text to a file named
*/ 
void encryptBatch(queue_t *q, int batchNum, int batchSize) {
    if (qsize(q) == 0) return;

    // Prepare pipe
    int pipefd[2];
    if (pipe(pipefd) == -1) {
        perror("pipe failed");
        exit(1);
    }

    pid_t pid = fork();
    if (pid < 0) {
        perror("fork failed");
        exit(1);
    } else if (pid == 0) {
        // Child process
        close(pipefd[1]); // close write end
        dup2(pipefd[0], STDIN_FILENO);  // redirect stdin to read from pipe
        close(pipefd[0]);

        // Prepare output file
        char filename[128];
        snprintf(filename, sizeof(filename), "output_%d.txt", batchNum);
        FILE *out = fopen(filename, "w");
        if (!out) {
            perror("Failed to open output file");
            exit(1);
        }
        dup2(fileno(out), STDOUT_FILENO); // redirect stdout to file
        fclose(out);

        // Execute cipher in batch mode (-s)
        execl("./cipher", "cipher", "-s", NULL);
        perror("execl failed");
        exit(1);
    } else {
        // Parent process
        close(pipefd[0]); // close read end

        // Write up to batchSize words to child stdin
        int count = 0;
        while (count < batchSize && qsize(q) > 0) {
            char *word = (char *)popQ(q);
            if (!word) break;
            dprintf(pipefd[1], "%s\n", word);
            free(word); // free memory after sending
            count++;
        }

        close(pipefd[1]); // finished writing
        wait(NULL);       // wait for child to finish
    }
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <wordfile>\n", argv[0]);
        return 1;
    }

    const char *wordFile = argv[1];
    queue_t q = { NULL, NULL, 0 }; // initialize empty queue

    //  read words into queue
    int totalWords = readWordsIntoQueue(wordFile, &q);
    if (totalWords < 0) return 1;
    printf("Loaded %d words into queue.\n", totalWords);

    //  process batches
    int batchNum = 1;
    while (qsize(&q) > 0) {
        encryptBatch(&q, batchNum, BATCH_SIZE);
        printf("Batch %d encrypted.\n", batchNum);
        batchNum++;
    }

    printf("All words encrypted. Check output_<n>.txt files.\n");
    return 0;
}
