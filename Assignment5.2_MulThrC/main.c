/*
 * main.c / Assignment 5 - Multithreading in C
 *
 * ZW / CS5600 / Northeastern University
 * Fall 2025 / Oct 4, 2025
 *
 * Description:
 *   This program reads a text file of words (generated by genRandWords-wang.c),
 *   stores each word into a generic queue (queue.c / queue.h), and performs
 *   batch encryption using Polybius cipher (polybius.c) via multiple threads.
 *   Each batch encrypts 100 words at a time, and outputs results to individual
 *   files (output_<n>.txt).
 *
 */

#define _POSIX_C_SOURCE 200809L
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include "queue.h"
#include "polybius.h"

#define BATCH_SIZE 100          // number of words per encryption batch
#define MAX_WORD_LEN 64         // max length of a word

typedef struct {
    char **words;    // words in this batch
    int count;       // how many words
    int batchNum;    // for naming output file
} batch_t;

/* Function: readWordsIntoQueue
* 
* Reads words from a file and stores them into the provided queue.
* Returns the number of words read.
*/
int readWordsIntoQueue(const char *filename, queue_t *q) {
    FILE *fp = fopen(filename, "r");
    if (!fp) {
        perror("Error opening word file");
        return -1;
    }

    char buffer[MAX_WORD_LEN];
    int count = 0;
    while (fscanf(fp, "%63s", buffer) == 1) {
        // Duplicate the word for storage in queue
        char *word = strdup(buffer);
        if (!word) {
            fprintf(stderr, "Memory allocation failed for word\n");
            fclose(fp);
            return -1;
        }
        add2q(q, word);
        count++;
    }

    fclose(fp);
    return count;
}

/* Thread function: encryptBatchThread
 *
 * Encrypts all words in a batch using pbEncode,
 * writes results to output_<batchNum>.txt
 */
void *encryptBatchThread(void *arg) {
    batch_t *batch = (batch_t *)arg;

    char filename[64];
    snprintf(filename, sizeof(filename), "output_%d.txt", batch->batchNum);
    FILE *fp = fopen(filename, "w");
    if (!fp) {
        perror("Error opening output file");
        pthread_exit(NULL);
    }

    polybius_table_t pt;
    initTable(&pt);

    for (int i = 0; i < batch->count; i++) {
        char *encrypted = pbEncode(batch->words[i], &pt);
        fprintf(fp, "%s\n", encrypted);
        free(encrypted);
        free(batch->words[i]);
    }

    fclose(fp);
    free(batch->words);
    free(batch);
    pthread_exit(NULL);
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <wordfile>\n", argv[0]);
        return 1;
    }

    const char *wordFile = argv[1];
    queue_t q = { NULL, NULL, 0 }; // initialize empty queue

    int totalWords = readWordsIntoQueue(wordFile, &q);
    if (totalWords < 0) return 1;
    printf("Loaded %d words into queue.\n", totalWords);

    pthread_t threads[1024]; // assume at most 1024 batches
    int threadCount = 0;
    int batchNum = 1;

    while (qsize(&q) > 0) {
        int n = (qsize(&q) < BATCH_SIZE) ? qsize(&q) : BATCH_SIZE;

        // allocate batch
        batch_t *batch = malloc(sizeof(batch_t));
        batch->words = malloc(sizeof(char*) * n);
        batch->count = n;
        batch->batchNum = batchNum;

        for (int i = 0; i < n; i++) {
            batch->words[i] = (char *)popQ(&q);
        }

        // create thread for this batch
        if (pthread_create(&threads[threadCount], NULL, encryptBatchThread, batch) != 0) {
            perror("pthread_create failed");
            return 1;
        }

        printf("Batch %d dispatched to thread.\n", batchNum);

        threadCount++;
        batchNum++;
    }

    // wait for all threads
    for (int i = 0; i < threadCount; i++) {
        pthread_join(threads[i], NULL);
    }

    printf("All words encrypted. Check output_<n>.txt files.\n");
    return 0;
}
